classdef tower < handle
    %TOWER Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        scheduler
        planes
        preamble
        mapping
        jitter
        equalizer
        nr_tiles_dc
        nr_tiles_rl
    end
    
    methods
        function obj = tower(config)
            obj.scheduler = schedulers.scheduler_factory(config);
            obj.scheduler.tower = obj;
            obj.mapping = config.mapping;
            obj.jitter = config.timing_jitter;
            obj.equalizer = ones(config.FFT_size, 1);
            obj.nr_tiles_dc             = config.nr_tiles_dc;
            obj.nr_tiles_rl             = config.nr_tiles_rl;
        end
        
        function [nr_attached] =  attach_plane(obj, plane_id)
            found_idx = obj.planes == plane_id;
            if sum(found_idx) > 0
                nr_attached = 0; % was already attached
            else
                obj.planes = [obj.planes plane_id];
                nr_attached = 1;
            end
        end
        
        function [nr_dropped] = drop_plane(obj, plane_id)
            drop_idx = obj.planes == plane_id;
            nr_dropped = sum(drop_idx);
            obj.planes = obj.planes(~nr_dropped);
        end
        
        function [received_datastream, sliced_signal] = receiver(obj, planes, snr_dB)
            
            traces = [planes.trace];
            input_signal = sum(vertcat(traces.last_received_signal), 1);
            [input_signal, noise_power] = obj.awgn_channel_response(input_signal, snr_dB);
            if strcmp(obj.jitter, 'on')
                max_delay = 8;
                s_power = norm(input_signal)^2/length(input_signal);
                    deviation = sqrt(s_power/2);
                    %input_signal = [input_signal, normrnd(0, deviation, 1, max_delay)+1j*normrnd(0, deviation, 1, max_delay) ];
                    input_signal = [input_signal, zeros(1, max_delay)];
                    timing_shift = randi([0 max_delay], 1, 1);
                    input_signal = circshift(input_signal, [0, timing_shift]);
            end
            
                for i_ = 1:length(planes)
                     
                    [planes(i_).trace.last_received_data,...
                        planes(i_).trace.last_received_sliced_signal]...
                        = network_elements.tower.ofdm_receiver(input_signal,...
                                                                obj.nr_tiles_dc,...
                                                                obj.nr_tiles_rl,...
                                                                obj, planes(i_),...
                                                                planes(i_).side,...
                                                                noise_power);
                end
        end
        function [data_stream, sliced_signal] = slicer_4QAM(obj, input_signal)
            sliced_signal = 1/sqrt(2)*...
                (sign(real(input_signal))+1j*sign(imag(input_signal)));
            alphabet_ind = [0 1 2 3]*bsxfun(@eq, obj.mapping.C4QAM, reshape(sliced_signal, 1, []));
            data_mat = [floor(alphabet_ind./2);mod(alphabet_ind, 2) ];
            data_stream = reshape(data_mat, 1, []);
        end
        
        function [output_stream, noise] = awgn_channel_response(obj, input_stream, snr_dB)
            % Since the SNR is defined over the bit energy, we need the
            % fraction of the signal that actually carries bits. 
            information_symbol_ratio = (38*2+48*4) * ... Nr data symbols per 2 tiles 
                                        obj.nr_tiles_dc * ... Nr data tiles in dc frame 
                                        obj.nr_tiles_rl / ... Nr tiles in one data frame 
                                        length(input_stream);
            
            % Right now, this is calculated as receive SNR. Therefore, The
            % received power is calculated:
            av_power_input = norm(input_stream).^2/length(input_stream);
            
            bits_per_symbol = log2(length(obj.mapping.chosen));
            
            noise = 10.^(-snr_dB./10) *... Noise power for 1 bit per symbol and unit transmit power
                information_symbol_ratio * ... Correction for information ratio
                av_power_input/bits_per_symbol; % Correction for receive ratio and Power per Symbol vs Power per Bit
            
            noise_signal = normrnd(0, sqrt(noise/2), size(input_stream))+1j*normrnd(0, sqrt(noise/2), size(input_stream));
            output_stream = input_stream+noise_signal;
        end
    end
    
end

